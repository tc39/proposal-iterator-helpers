<!DOCTYPE html>
<meta charset="utf-8">
<pre class="metadata">
title: Iterator Helpers
status: proposal
stage: 2
location: https://tc39.es/proposal-iterator-helpers
copyright: false
contributors: Gus Caplan
</pre>
<style>
  ins.block {
    font-weight: bold;
    font-style: italic;
  }
  hr {
    height: 0.25em;
    background: #ccc;
    border: 0;
    margin: 2em 0;
  }
  .unicode-property-table {
    table-layout: fixed;
    width: 100%;
    font-size: 80%;
  }
  .unicode-property-table ul {
    padding-left: 0;
    list-style: none;
  }
  #metadata-block {
    margin: 4em 0;
    padding: 10px;
    border: 1px solid #ee8421;
  }
  #metadata-block h1 {
    font-size: 1.5em;
    margin-top: 0;
  }
  #metadata-block > ul {
    list-style-type: none;
    margin: 0; padding: 0;
  }
</style>

<div id="metadata-block">
  <h1>Contributing to this Proposal</h1>
  <p>This proposal is developed on GitHub with the help of the ECMAScript community. There are a number of ways to contribute to the development of this specification:</p>
  <ul>
    <li>GitHub Repository: <a href="https://github.com/tc39/proposal-iterator-helpers">https://github.com/tc39/proposal-iterator-helpers</a></li>
    <li>Issues: <a href="https://github.com/tc39/proposal-iterator-helpers/issues">All Issues</a>, <a href="https://github.com/tc39/proposal-iterator-helpers/issues/new">File a New Issue</a></li>
    <li>Pull Requests: <a href="https://github.com/tc39/proposal-iterator-helpers/pulls">All Pull Requests</a>, <a href="https://github.com/tc39/proposal-iterator-helpers/pulls/new">Create a New Pull Request</a></li>
    <!-- <li>Test Suite: <a href="https://github.com/tc39/test262">Test262</a></li> -->
    <li>
      <p>Community:</p>
      <ul>
        <li>Discourse: <a href="https://es.discourse.group">https://es.discourse.group</a></li>
        <li>Chat: <a href="https://github.com/tc39/how-we-work/blob/HEAD/matrix-guide.md">Matrix</a></li>
      </ul>
    </li>
  </ul>
</div>

<emu-clause id="sec-well-known-intrinsic-objects">
  <h1>Well-Known Intrinsic Objects</h1>

  <emu-table id="table-7" caption="Well-Known Intrinsic Objects">
    <table>
      <tr>
        <th>
          Intrinsic Name
        </th>
        <th>
          Global Name
        </th>
        <th>
          ECMAScript Language Association
        </th>
      </tr>
      <tr>
        <td>
          <ins>%AsyncIterator%</ins>
        </td>
        <td>
          <ins>`AsyncIterator`</ins>
        </td>
        <td>
          <ins>The `AsyncIterator` constructor (<emu-xref href="#sec-asynciterator-constructor"></emu-xref>)</ins>
        </td>
      </tr>
      <tr>
        <td>
          %AsyncIteratorPrototype%
        </td>
        <td>
          <ins>`AsyncIterator.prototype`</ins>
        </td>
        <td>
          An object that all standard built-in async iterator objects indirectly inherit from
          <p><ins>The initial value of the *"prototype"* data property of %AsyncIterator%; i.e., %AsyncIterator.prototype%</ins></p>
        </td>
      </tr>
      <tr>
        <td>
          <ins>%Iterator%</ins>
        </td>
        <td>
          <ins>`Iterator`</ins>
        </td>
        <td>
          <ins>The `Iterator` constructor (<emu-xref href="#sec-iterator-constructor"></emu-xref>)</ins>
        </td>
      </tr>
      <tr>
        <td>
          %IteratorPrototype%
        </td>
        <td>
          <ins>`Iterator.prototype`</ins>
        </td>
        <td>
          An object that all standard built-in iterator objects indirectly inherit from
          <p><ins>The initial value of the *"prototype"* data property of %Iterator%; i.e., %Iterator.prototype%</ins></p>
        </td>
      </tr>
    </table>
  </emu-table>
</emu-clause>

<emu-clause id="sec-abstract-operations">
  <h1>Abstract Operations</h1>

  <emu-clause id="sec-operations-on-iterator-objects">
    <h1>Operations on Iterator Objects</h1>

    <emu-clause id="sec-getiteratordirect" type="abstract operation">
      <h1>
        GetIteratorDirect (
          _obj_: an ECMAScript language value,
        ): either a normal completion containing an IteratorRecord or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If _obj_ is not an Object, throw a *TypeError* exception.
        1. Let _nextMethod_ be ? GetV(_obj_, `"next"`).
        1. If IsCallable(_nextMethod_) is *false*, throw a *TypeError* exception.
        1. Let _iteratorRecord_ be Record { [[Iterator]]: _obj_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* }.
        1. Return _iteratorRecord_.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-control-abstraction-objects">
  <h1>Control Abstraction Objects</h1>

  <emu-clause id="sec-iteration">
    <h1>Iteration</h1>

    <emu-clause id="sec-iterator-abstract-operations">
      <h1>Iterator Abstract Operations</h1>

      <emu-clause id="sec-ifabruptcloseasynciterator" aoid="IfAbruptCloseAsyncIterator">
        <h1>IfAbruptCloseAsyncIterator ( _value_, _iteratorRecord_ )</h1>
        <p>IfAbruptCloseAsyncIterator is a shorthand for a sequence of algorithm steps that use an Iterator Record. An algorithm step of the form:</p>
        <emu-alg>
          1. IfAbruptCloseAsyncIterator(_value_, _iteratorRecord_).
        </emu-alg>
        <p>means the same thing as:</p>
        <emu-alg>
          1. If _value_ is an abrupt completion, then
            1. Perform ? AsyncIteratorClose(_iteratorRecord_, _value_).
            1. Return _value_.
          1. Else if _value_ is a Completion Record, set _value_ to _value_.[[Value]].
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-iterator-objects">
      <h1>Iterator Objects</h1>

      <emu-clause id="sec-iterator-constructor">
        <h1>The Iterator Constructor</h1>
        <p>The <dfn>Iterator</dfn> constructor:</p>
        <ul>
          <li>is <dfn>%Iterator%</dfn>.</li>
          <li>is the initial value of the *Iterator* property of the global object.</li>
          <li>is designed to be subclassable. It may be used as the value of an *extends* clause of a class definition.</li>
        </ul>

        <emu-clause id="sec-iterator">
          <h1>Iterator ( )</h1>
          <p>When the `Iterator` function is called, the following steps are taken:</p>
          <emu-alg>
            1. If NewTarget is *undefined* or the active function object, throw a *TypeError* exception.
            1. Return ? OrdinaryCreateFromConstructor(NewTarget, *"%Iterator.prototype%"*).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-iterator-constructor">
        <h1>Properties of the Iterator Constructor</h1>

        <emu-clause id="sec-iterator.prototype">
          <h1>Iterator.prototype</h1>
          <p>The initial value of Iterator.prototype is %Iterator.prototype%.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        </emu-clause>

        <emu-clause id="sec-iterator.from">
          <h1>Iterator.from ( _O_ )</h1>
          <emu-alg>
            1. Let _usingIterator_ be ? GetMethod(_O_, @@iterator).
            1. If _usingIterator_ is not *undefined*, then
              1. Let _iteratorRecord_ be ? GetIterator(_O_, ~sync~, _usingIterator_).
              1. If IsCallable(_iteratorRecord_.[[NextMethod]]) is *false*, throw a *TypeError* exception.
              1. Let _hasInstance_ be ? OrdinaryHasInstance(%Iterator%, _iteratorRecord_.[[Iterator]]).
              1. If _hasInstance_ is *true*, then
                1. Return _iteratorRecord_.[[Iterator]].
            1. Else, Let _iteratorRecord_ be ? GetIteratorDirect(_O_).
            1. Let _wrapper_ be ! ObjectCreate(%WrapForValidIteratorPrototype%, &laquo; [[Iterated]] &raquo;).
            1. Set _wrapper_.[[Iterated]] to _iteratorRecord_.
            1. Return _wrapper_.
          </emu-alg>

          <emu-clause id="sec-wrapforvaliditeratorprototype-object">
            <h1>The %WrapForValidIteratorPrototype% Object</h1>
            <p>The <dfn>%WrapForValidIteratorPrototype%</dfn> object:</p>
            <ul>
              <li>has a [[Prototype]] internal slot whose value is %Iterator.prototype%.</li>
            </ul>

            <emu-clause id="sec-wrapforvaliditeratorprototype.next">
              <h1>%WrapForValidIteratorPrototype%.next ( )</h1>
              <emu-alg>
                1. Let _O_ be *this* value.
                1. Perform ? RequireInternalSlot(_O_, [[Iterated]]).
                1. Let _iteratorRecord_ be _O_.[[Iterated]].
                1. Return ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]]).
              </emu-alg>
            </emu-clause>

            <emu-clause id="sec-wrapforvaliditeratorprototype.return">
              <h1>%WrapForValidIteratorPrototype%.return ( )</h1>
              <emu-alg>
                1. Let _O_ be *this* value.
                1. Perform ? RequireInternalSlot(_O_, [[Iterated]]).
                1. Let _iterator_ be _O_.[[Iterated]].[[Iterator]].
                1. Assert: _iterator_ is an Object.
                1. Let _returnMethod_ be ? GetMethod(_iterator_, *"return"*).
                1. If _returnMethod_ is *undefined*, then
                  1. Return CreateIterResultObject(*undefined*, *true*).
                1. Return ? Call(_returnMethod_, _iterator_).
              </emu-alg>
            </emu-clause>
          </emu-clause>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-asynciterator-objects">
      <h1>AsyncIterator Objects</h1>

      <emu-clause id="sec-asynciterator-constructor">
        <h1>The AsyncIterator Constructor</h1>
        <p>The <dfn>AsyncIterator</dfn> constructor:</p>
        <ul>
          <li>is <dfn>%AsyncIterator%</dfn>.</li>
          <li>is the initial value of the *AsyncIterator* property of the global object.</li>
          <li>is designed to be subclassable. It may be used as the value of an *extends* clause of a class definition.</li>
        </ul>

        <emu-clause id="sec-asynciterator">
          <h1>AsyncIterator ( )</h1>
          <p>When the `AsyncIterator` function is called, the following steps are taken:</p>
          <emu-alg>
            1. If NewTarget is *undefined* or the active function object, throw a *TypeError* exception.
            1. Return ? OrdinaryCreateFromConstructor(NewTarget, *"%AsyncIterator.prototype%"*).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-asynciterator-constructor">
        <h1>Properties of the AsyncIterator Constructor</h1>

        <emu-clause id="sec-asynciterator.prototype">
          <h1>AsyncIterator.prototype</h1>
          <p>The initial value of AsyncIterator.prototype is %AsyncIterator.prototype%.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        </emu-clause>

        <emu-clause id="sec-asynciterator.from">
          <h1>AsyncIterator.from ( _O_ )</h1>
          <emu-alg>
            1. Let _usingIterator_ be ? GetMethod(_O_, @@asyncIterator).
            1. Let _iteratorRecord_ be *undefined*.
            1. If _usingIterator_ is not *undefined*, then
              1. Set _iteratorRecord_ to ? GetIterator(_O_, ~async~, _usingIterator_).
              1. If IsCallable(_iteratorRecord_.[[NextMethod]]) is *false*, throw a *TypeError* exception.
              1. Let _hasInstance_ be ? OrdinaryHasInstance(%AsyncIterator%, _iteratorRecord_.[[Iterator]]).
              1. If _hasInstance_ is *true*, then
                1. Return _iteratorRecord_.[[Iterator]].
            1. If _iteratorRecord_ is *undefined*, then
              1. Set _usingIterator_ to ? GetMethod(_O_, @@iterator).
              1. If _usingIterator_ is not *undefined*, then
                1. Let _syncIteratorRecord_ be ? GetIterator(_O_, ~sync~, _usingIterator_).
                1. If IsCallable(_syncIteratorRecord_.[[NextMethod]]) is *false*, throw a *TypeError* exception.
                1. Set _iteratorRecord_ to CreateAsyncFromSyncIterator(_syncIteratorRecord_).
            1. If _iteratorRecord_ is *undefined*, set _iteratorRecord_ to ? GetIteratorDirect(_O_).
            1. Let _wrapper_ be ! ObjectCreate(%WrapForValidAsyncIteratorPrototype%, &laquo; [[AsyncIterated]] &raquo;).
            1. Set _wrapper_.[[AsyncIterated]] to _iteratorRecord_.
            1. Return _wrapper_.
          </emu-alg>

          <emu-clause id="sec-wrapforvalidasynciteratorprototype-object">
            <h1>The %WrapForValidAsyncIteratorPrototype% Object</h1>
            <p>The <dfn>%WrapForValidAsyncIteratorPrototype%</dfn> object:</p>

            <ul>
              <li>is an ordinary object.</li>
              <li>has a [[Prototype]] internal slot whose value is %AsyncIterator.prototype%.</li>
              <li>has the following properties:</li>
            </ul>

            <emu-clause id="sec-wrapforvalidasynciteratorprototype.next">
              <h1>%WrapForValidAsyncIteratorPrototype%.next ( )</h1>
              <emu-alg>
                1. Let _O_ be *this* value.
                1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
                1. Let _check_ be Completion(RequireInternalSlot(_O_, [[AsyncIterated]])).
                1. IfAbruptRejectPromise(_check_, _promiseCapability_).
                1. Let _result_ be Completion(IteratorNext(_O_.[[AsyncIterated]])).
                1. IfAbruptRejectPromise(_result_, _promiseCapability_).
                1. Return ? PromiseResolve(%Promise%, _result_).
              </emu-alg>
            </emu-clause>

            <emu-clause id="sec-wrapforvalidasynciteratorprototype.return">
              <h1>%WrapForValidAsyncIteratorPrototype%.return ( )</h1>
              <emu-alg>
                1. Let _O_ be *this* value.
                1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
                1. Let _check_ be Completion(RequireInternalSlot(_O_, [[AsyncIterated]])).
                1. IfAbruptRejectPromise(_check_, _promiseCapability_).
                1. Let _iterator_ be _O_.[[AsyncIterated]].[[Iterator]].
                1. Assert: _iterator_ is an Object.
                1. Let _returnMethod_ be Completion(GetMethod(_iterator_, *"return"*)).
                1. IfAbruptRejectPromise(_returnMethod_, _promiseCapability_).
                1. If _returnMethod_ is *undefined*, then
                  1. Return ! PromiseResolve(%Promise%, CreateIterResultObject(*undefined*, *true*)).
                1. Let _result_ be Completion(Call(_returnMethod_, _iterator_)).
                1. IfAbruptRejectPromise(_result_, _promiseCapability_).
                1. Return ? PromiseResolve(%Promise%, _result_).
              </emu-alg>
            </emu-clause>
          </emu-clause>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-iterator-helper-objects">
      <h1>Iterator Helper Objects</h1>
      <p>An Iterator Helper object is an ordinary object that represents a lazy transformation of some specific source iterator object. There is not a named constructor for Iterator Helper objects. Instead, Iterator Helper objects are created by calling certain methods of Iterator instance objects.</p>

      <emu-clause id="sec-%iteratorhelperprototype%-object">
        <h1>The %IteratorHelperPrototype% Object</h1>
        <p>The <dfn>%IteratorHelperPrototype%</dfn> object:</p>
        <ul>
          <li>has properties that are inherited by all Iterator Helper Objects.</li>
          <li>is an ordinary object.</li>
          <li>has a [[Prototype]] internal slot whose value is %Iterator.prototype%.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-%iteratorhelperprototype%.next">
          <h1>%IteratorHelperPrototype%.next ( )</h1>
          <emu-alg>
            1. Return ? GeneratorResume(*this* value, *undefined*, *"Iterator Helper"*).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%iteratorhelperprototype%.return">
          <h1>%IteratorHelperPrototype%.return ( )</h1>
          <emu-alg>
            1. Let _C_ be Completion { [[Type]]: ~return~, [[Value]]: *undefined*, [[Target]]: ~empty~ }.
            1. Return ? GeneratorResumeAbrupt(*this* value, _C_, *"Iterator Helper"*).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%iteratorhelperprototype%-@@tostringtag">
          <h1>%IteratorHelperPrototype% [ @@toStringTag ]</h1>
          <p>The initial value of the @@toStringTag property is the String value *"Iterator Helper"*.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-iterator-helper-objects">
      <h1>Async Iterator Helper Objects</h1>
      <p>An Async Iterator Helper object is an ordinary object that represents a lazy transformation of some specific source async iterator object. There is not a named constructor for Async Iterator Helper objects. Instead, Async Iterator Helper objects are created by calling certain methods of AsyncIterator instance objects.</p>

      <emu-clause id="sec-%asynciteratorhelperprototype%-object">
        <h1>The %AsyncIteratorHelperPrototype% Object</h1>
        <p>The <dfn>%AsyncIteratorHelperPrototype%</dfn> object:</p>
        <ul>
          <li>has properties that are inherited by all Async Iterator Helper Objects.</li>
          <li>is an ordinary object.</li>
          <li>has a [[Prototype]] internal slot whose value is %AsyncIterator.prototype%.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-%asynciteratorhelperprototype%.next">
          <h1>%AsyncIteratorHelperPrototype%.next ( )</h1>
          <emu-alg>
            1. Return AsyncGeneratorNext(*this* value, *"Async Iterator Helper"*, *undefined*).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%asynciteratorhelperprototype%.return">
          <h1>%AsyncIteratorHelperPrototype%.return ( )</h1>
          <emu-alg>
            1. Return AsyncGeneratorReturn(*this* value, *"Async Iterator Helper"*, *undefined*).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%asynciteratorhelperprototype%-@@tostringtag">
          <h1>%AsyncIteratorHelperPrototype% [ @@toStringTag ]</h1>
          <p>The initial value of the @@toStringTag property is the String value *"Async Iterator Helper"*.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-iteratorprototype">
      <h1>Iterator.prototype</h1>
      <p>The <dfn>Iterator prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%Iterator.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
      </ul>

      <emu-clause id="sec-iteratorprototype.constructor">
        <h1>Iterator.prototype.constructor</h1>
        <p>The initial value of %Iterator.prototype%.constructor is %Iterator%.</p>
      </emu-clause>

      <emu-clause id="sec-iteratorprototype.map">
        <h1>Iterator.prototype.map ( _mapper_ )</h1>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. If IsCallable(_mapper_) is *false*, throw a *TypeError* exception.
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _iterated_ and _mapper_ and performs the following steps when called:
            1. Repeat,
              1. Let _next_ be ? IteratorStep(_iterated_).
              1. If _next_ is *false*, return *undefined*.
              1. Let _value_ be ? IteratorValue(_next_).
              1. Let _mapped_ be Completion(Call(_mapper_, *undefined*, &laquo; _value_ &raquo;)).
              1. IfAbruptCloseIterator(_mapped_, _iterated_).
              1. Let _completion_ be Completion(Yield(_mapped_)).
              1. IfAbruptCloseIterator(_completion_, _iterated_).
          1. Return CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iteratorprototype.filter">
        <h1>Iterator.prototype.filter ( _filterer_ )</h1>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. If IsCallable(_filterer_) is *false*, throw a *TypeError* exception.
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _iterated_ and _filterer_ and performs the following steps when called:
            1. Repeat,
              1. Let _next_ be ? IteratorStep(_iterated_).
              1. If _next_ is *false*, return *undefined*.
              1. Let _value_ be ? IteratorValue(_next_).
              1. Let _selected_ be Completion(Call(_filterer_, *undefined*, &laquo; _value_ &raquo;)).
              1. IfAbruptCloseIterator(_selected_, _iterated_).
              1. If ToBoolean(_selected_) is *true*, then
                1. Let _completion_ be Completion(Yield(_value_)).
                1. IfAbruptCloseIterator(_completion_, _iterated_).
          1. Return CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iteratorprototype.take">
        <h1>Iterator.prototype.take ( _limit_ )</h1>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. Let _numLimit_ be ? ToNumber(_limit_).
          1. If _numLimit_ is *NaN*, throw a *RangeError* exception.
          1. Let _integerLimit_ be ! ToIntegerOrInfinity(_numLimit_).
          1. If _integerLimit_ &lt; 0, throw a *RangeError* exception.
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _iterated_ and _integerLimit_ and performs the following steps when called:
            1. Let _remaining_ be _integerLimit_.
            1. Repeat,
              1. If _remaining_ is 0, then
                1. Return ? IteratorClose(_iterated_, NormalCompletion(*undefined*)).
              1. If _remaining_ is not +∞, then
                1. Set _remaining_ to _remaining_ - 1.
              1. Let _next_ be ? IteratorStep(_iterated_).
              1. If _next_ is *false*, return *undefined*.
              1. Let _completion_ be Completion(Yield(? IteratorValue(_next_))).
              1. IfAbruptCloseIterator(_completion_, _iterated_).
          1. Return CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iteratorprototype.drop">
        <h1>Iterator.prototype.drop ( _limit_ )</h1>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. Let _numLimit_ be ? ToNumber(_limit_).
          1. If _numLimit_ is *NaN*, throw a *RangeError* exception.
          1. Let _integerLimit_ be ! ToIntegerOrInfinity(_numLimit_).
          1. If _integerLimit_ &lt; 0, throw a *RangeError* exception.
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _iterated_ and _integerLimit_ and performs the following steps when called:
            1. Let _remaining_ be _integerLimit_.
            1. Repeat, while _remaining_ &gt; 0,
              1. If _remaining_ is not +∞, then
                1. Set _remaining_ to _remaining_ - 1.
              1. Let _next_ be ? IteratorStep(_iterated_).
              1. If _next_ is *false*, return *undefined*.
            1. Repeat,
              1. Let _next_ be ? IteratorStep(_iterated_).
              1. If _next_ is *false*, return *undefined*.
              1. Let _completion_ be Completion(Yield(? IteratorValue(_next_))).
              1. IfAbruptCloseIterator(_completion_, _iterated_).
          1. Return CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iteratorprototype.indexed">
        <h1>Iterator.prototype.indexed ( )</h1>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _iterated_ and performs the following steps when called:
            1. Let _index_ be 0.
            1. Repeat,
              1. Let _next_ be ? IteratorStep(_iterated_).
              1. If _next_ is *false*, return *undefined*.
              1. Let _value_ be ? IteratorValue(_next_).
              1. Let _pair_ be CreateArrayFromList(&laquo; 𝔽(_index_), _value_ &raquo;).
              1. Set _index_ to _index_ + 1.
              1. Let _completion_ be Completion(Yield(_pair_)).
              1. IfAbruptCloseIterator(_completion_, _iterated_).
          1. Return CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iteratorprototype.flatmap">
        <h1>Iterator.prototype.flatMap ( _mapper_ )</h1>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. If IsCallable(_mapper_) is *false*, throw a *TypeError* exception.
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _iterated_ and _mapper_ and performs the following steps when called:
            1. Repeat,
              1. Let _next_ be ? IteratorStep(_iterated_).
              1. If _next_ is *false*, return *undefined*.
              1. Let _value_ be ? IteratorValue(_next_).
              1. Let _mapped_ be Completion(Call(_mapper_, *undefined*, &laquo; _value_ &raquo;)).
              1. IfAbruptCloseIterator(_mapped_, _iterated_).
              1. Let _innerIterator_ be Completion(GetIterator(_mapped_, ~sync~)).
              1. IfAbruptCloseIterator(_innerIterator_, _iterated_).
              1. Let _innerAlive_ be *true*.
              1. Repeat, while _innerAlive_ is *true*,
                1. Let _innerNext_ be Completion(IteratorStep(_innerIterator_)).
                1. IfAbruptCloseIterator(_innerNext_, _iterated_).
                1. If _innerNext_ is *false*, then
                  1. Set _innerAlive_ to *false*.
                1. Else,
                  1. Let _innerValue_ be Completion(IteratorValue(_innerNext_)).
                  1. IfAbruptCloseIterator(_innerValue_, _iterated_).
                  1. Let _completion_ be Completion(Yield(_innerValue_)).
                  1. If _completion_ is an abrupt completion, then
                    1. Let _backupCompletion_ be Completion(IteratorClose(_innerIterator_, _completion_)).
                    1. IfAbruptCloseIterator(_backupCompletion_, _iterated_).
                    1. Return ? IteratorClose(_completion_, _iterated_).
          1. Return CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iteratorprototype.reduce">
        <h1>Iterator.prototype.reduce ( _reducer_ [ , _initialValue_ ] )</h1>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. If IsCallable(_reducer_) is *false*, throw a *TypeError* exception.
          1. If _initialValue_ is not present, then
            1. Let _next_ be ? IteratorStep(_iterated_).
            1. If _next_ is *false*, throw a *TypeError* exception.
            1. Let _accumulator_ be ? IteratorValue(_next_).
          1. Else,
            1. Let _accumulator_ be _initialValue_.
          1. Repeat,
            1. Let _next_ be ? IteratorStep(_iterated_).
            1. If _next_ is *false*, return _accumulator_.
            1. Let _value_ be ? IteratorValue(_next_).
            1. Let _result_ be Completion(Call(_reducer_, *undefined*, &laquo; _accumulator_, _value_ &raquo;)).
            1. IfAbruptCloseIterator(_result_, _iterated_).
            1. Set _accumulator_ to _result_.[[Value]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iteratorprototype.toarray">
        <h1>Iterator.prototype.toArray ( )</h1>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. Let _items_ be a new empty List.
          1. Repeat,
            1. Let _next_ be ? IteratorStep(_iterated_).
            1. If _next_ is *false*, return CreateArrayFromList(_items_).
            1. Let _value_ be ? IteratorValue(_next_).
            1. Append _value_ to _items_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iteratorprototype.toasync">
        <h1>Iterator.prototype.toAsync ( )</h1>
        <emu-alg>
          1. Let _syncIteratorRecord_ be ? GetIteratorDirect(*this* value).
          1. Let _asyncIteratorRecord_ be CreateAsyncFromSyncIterator(_syncIteratorRecord_).
          1. Let _wrapper_ be ! ObjectCreate(%WrapForValidAsyncIteratorPrototype%, &laquo; [[AsyncIterated]] &raquo;).
          1. Set _wrapper_.[[AsyncIterated]] to _asyncIteratorRecord_.
          1. Return _wrapper_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iteratorprototype.foreach">
        <h1>Iterator.prototype.forEach ( _fn_ )</h1>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. If IsCallable(_fn_) is *false*, throw a *TypeError* exception.
          1. Repeat,
            1. Let _next_ be ? IteratorStep(_iterated_).
            1. If _next_ is *false*, return *undefined*.
            1. Let _value_ be ? IteratorValue(_next_).
            1. Let _result_ be Completion(Call(_fn_, *undefined*, &laquo; _value_ &raquo;)).
            1. IfAbruptCloseIterator(_result_, _iterated_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iteratorprototype.some">
        <h1>Iterator.prototype.some ( _fn_ )</h1>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. If IsCallable(_fn_) is *false*, throw a *TypeError* exception.
          1. Repeat,
            1. Let _next_ be ? IteratorStep(_iterated_).
            1. If _next_ is *false*, return *false*.
            1. Let _value_ be ? IteratorValue(_next_).
            1. Let _result_ be Completion(Call(_fn_, *undefined*, &laquo; _value_ &raquo;)).
            1. IfAbruptCloseIterator(_result_, _iterated_).
            1. If ToBoolean(_result_) is *true*, return ? IteratorClose(_iterated_, NormalCompletion(*true*)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iteratorprototype.every">
        <h1>Iterator.prototype.every ( _fn_ )</h1>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. If IsCallable(_fn_) is *false*, throw a *TypeError* exception.
          1. Repeat,
            1. Let _next_ be ? IteratorStep(_iterated_).
            1. If _next_ is *false*, return *true*.
            1. Let _value_ be ? IteratorValue(_next_).
            1. Let _result_ be Completion(Call(_fn_, *undefined*, &laquo; _value_ &raquo;)).
            1. IfAbruptCloseIterator(_result_, _iterated_).
            1. If ToBoolean(_result_) is *false*, return ? IteratorClose(_iterated_, NormalCompletion(*false*)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iteratorprototype.find">
        <h1>Iterator.prototype.find ( _fn_ )</h1>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. If IsCallable(_fn_) is *false*, throw a *TypeError* exception.
          1. Repeat,
            1. Let _next_ be ? IteratorStep(_iterated_).
            1. If _next_ is *false*, return *undefined*.
            1. Let _value_ be ? IteratorValue(_next_).
            1. Let _result_ be Completion(Call(_fn_, *undefined*, &laquo; _value_ &raquo;)).
            1. IfAbruptCloseIterator(_result_, _iterated_).
            1. If ToBoolean(_result_) is *true*, return ? IteratorClose(_iterated_, NormalCompletion(_value_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iteratorprototype-@@tostringtag">
        <h1>Iterator.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value "Iterator".</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-asynciteratorprototype">
      <h1>AsyncIterator.prototype</h1>
      <p>The <dfn>AsyncIterator prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%AsyncIterator.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
      </ul>

      <emu-clause id="sec-asynciteratorprototype.constructor">
        <h1>AsyncIterator.prototype.constructor</h1>
        <p>The initial value of AsyncIterator.prototype.constructor is %AsyncIterator%.</p>
      </emu-clause>

      <emu-clause id="sec-asynciteratorprototype.map">
        <h1>AsyncIterator.prototype.map ( _mapper_ )</h1>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. If IsCallable(_mapper_) is *false*, throw a *TypeError* exception.
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _iterated_ and _mapper_ and performs the following steps when called:
            1. Repeat,
              1. Let _next_ be ? Await(? IteratorNext(_iterated_)).
              1. If ? IteratorComplete(_next_) is *true*, return *undefined*.
              1. Let _value_ be ? IteratorValue(_next_).
              1. Let _mapped_ be Completion(Call(_mapper_, *undefined*, &laquo; _value_ &raquo;)).
              1. IfAbruptCloseAsyncIterator(_mapped_, _iterated_).
              1. Set _mapped_ to Completion(Await(_mapped_)).
              1. IfAbruptCloseAsyncIterator(_mapped_, _iterated_).
              1. Let _completion_ be Completion(Yield(_mapped_)).
              1. IfAbruptCloseAsyncIterator(_completion_, _iterated_).
          1. Return CreateAsyncIteratorFromClosure(_closure_, *"Async Iterator Helper"*, %AsyncIteratorHelperPrototype%).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asynciteratorprototype.filter">
        <h1>AsyncIterator.prototype.filter ( _filterer_ )</h1>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. If IsCallable(_filterer_) is *false*, throw a *TypeError* exception.
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _iterated_ and _filterer_ and performs the following steps when called:
            1. Repeat,
              1. Let _next_ be ? Await(? IteratorNext(_iterated_)).
              1. If ? IteratorComplete(_next_) is *true*, return *undefined*.
              1. Let _value_ be ? IteratorValue(_next_).
              1. Let _selected_ be Completion(Call(_filterer_, *undefined*, &laquo; _value_ &raquo;)).
              1. IfAbruptCloseAsyncIterator(_selected_, _iterated_).
              1. Set _selected_ to Completion(Await(_selected_)).
              1. IfAbruptCloseAsyncIterator(_selected_, _iterated_).
              1. If ToBoolean(_selected_) is *true*, then
                1. Let _completion_ be Completion(Yield(_value_)).
                1. IfAbruptCloseAsyncIterator(_completion_, _iterated_).
          1. Return CreateAsyncIteratorFromClosure(_closure_, *"Async Iterator Helper"*, %AsyncIteratorHelperPrototype%).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asynciteratorprototype.take">
        <h1>AsyncIterator.prototype.take ( _limit_ )</h1>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. Let _numLimit_ be ? ToNumber(_limit_).
          1. If _numLimit_ is *NaN*, throw a *RangeError* exception.
          1. Let _integerLimit_ be ! ToIntegerOrInfinity(_numLimit_).
          1. If _integerLimit_ &lt; 0, throw a *RangeError* exception.
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _iterated_ and _integerLimit_ and performs the following steps when called:
            1. Let _remaining_ be _integerLimit_.
            1. Repeat,
              1. If _remaining_ is 0, then
                1. Return ? AsyncIteratorClose(_iterated_, NormalCompletion(*undefined*)).
              1. If _remaining_ is not +∞, then
                1. Set _remaining_ to _remaining_ - 1.
              1. Let _next_ be ? Await(? IteratorNext(_iterated_)).
              1. If ? IteratorComplete(_next_) is *true*, return *undefined*.
              1. Set _completion_ to Completion(Yield(? IteratorValue(_next_))).
              1. IfAbruptCloseAsyncIterator(_completion_, _iterated_).
          1. Return CreateAsyncIteratorFromClosure(_closure_, *"Async Iterator Helper"*, %AsyncIteratorHelperPrototype%).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asynciteratorprototype.drop">
        <h1>AsyncIterator.prototype.drop ( _limit_ )</h1>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. Let _numLimit_ be ? ToNumber(_limit_).
          1. If _numLimit_ is *NaN*, throw a *RangeError* exception.
          1. Let _integerLimit_ be ! ToIntegerOrInfinity(_numLimit_).
          1. If _integerLimit_ &lt; 0, throw a *RangeError* exception.
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _iterated_ and _integerLimit_ and performs the following steps when called:
            1. Let _remaining_ be _integerLimit_.
            1. Repeat, while _remaining_ &gt; 0,
              1. If _remaining_ is not +∞, then
                1. Set _remaining_ to _remaining_ - 1.
              1. Let _next_ be ? Await(? IteratorNext(_iterated_)).
              1. If ? IteratorComplete(_next_) is *true*, return *undefined*.
            1. Repeat,
              1. Let _next_ be ? Await(? IteratorNext(_iterated_)).
              1. If ? IteratorComplete(_next_) is *true*, return *undefined*.
              1. Let _completion_ be Completion(Yield(? IteratorValue(_next_))).
              1. IfAbruptCloseAsyncIterator(_completion_, _iterated_).
          1. Return CreateAsyncIteratorFromClosure(_closure_, *"Async Iterator Helper"*, %AsyncIteratorHelperPrototype%).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asynciteratorprototype.indexed">
        <h1>AsyncIterator.prototype.indexed ( )</h1>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _iterated_ and performs the following steps when called:
            1. Let _index_ be 0.
            1. Repeat,
              1. Let _next_ be ? Await(? IteratorNext(_iterated_)).
              1. If ? IteratorComplete(_next_) is *true*, return *undefined*.
              1. Let _value_ be ? IteratorValue(_next_).
              1. Let _pair_ be CreateArrayFromList(&laquo; _index_, _value_ &raquo;).
              1. Set _index_ to _index_ + 1.
              1. Let _completion_ be Completion(Yield(_pair_)).
              1. IfAbruptCloseAsyncIterator(_completion_, _iterated_).
          1. Return CreateAsyncIteratorFromClosure(_closure_, *"Async Iterator Helper"*, %AsyncIteratorHelperPrototype%).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asynciteratorprototype.flatmap">
        <h1>AsyncIterator.prototype.flatMap ( _mapper_ )</h1>
        <p>AsyncIterator.prototype.flatMap is a built-in async generator function which, when called, performs the following steps:</p>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. If IsCallable(_mapper_) is *false*, throw a *TypeError* exception.
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _iterated_ and _mapper_ and performs the following steps when called:
            1. Repeat,
              1. Let _next_ be ? Await(? IteratorNext(_iterated_)).
              1. If ? IteratorComplete(_next_) is *true*, return *undefined*.
              1. Let _value_ be ? IteratorValue(_next_).
              1. Let _mapped_ be Completion(Call(_mapper_, *undefined*, &laquo; _value_ &raquo;)).
              1. IfAbruptCloseAsyncIterator(_mapped_, _iterated_).
              1. Set _mapped_ to Completion(Await(_mapped_)).
              1. IfAbruptCloseAsyncIterator(_mapped_, _iterated_).
              1. Let _innerIterator_ be Completion(GetIterator(_mapped_, ~async~)).
              1. IfAbruptCloseAsyncIterator(_innerIterator_, _iterated_).
              1. Let _innerAlive_ be *true*.
              1. Repeat, while _innerAlive_ is *true*,
                1. Let _innerNextPromise_ be Completion(IteratorNext(_innerIterator_)).
                1. IfAbruptCloseAsyncIterator(_innerNextPromise_, _iterated_).
                1. Let _innerNext_ be Completion(Await(_innerNextPromise_)).
                1. IfAbruptCloseAsyncIterator(_innerNext_, _iterated_).
                1. Let _innerComplete_ be Completion(IteratorComplete(_innerNext_)).
                1. IfAbruptCloseAsyncIterator(_innerComplete_, _iterated_).
                1. If _innerComplete_ is *true*, then
                  1. Set _innerAlive_ to *false*.
                1. Else,
                  1. Let _innerValue_ be Completion(IteratorValue(_innerNext_)).
                  1. IfAbruptCloseAsyncIterator(_innerValue_, _iterated_).
                  1. [id="step-async-iterator-flatmap-yield"] Let _completion_ be Completion(Yield(_innerValue_)).
                  1. If _completion_ is a return completion, then
                    1. Let _backupCompletion_ be Completion(IteratorClose(_innerIterator_, _completion_)).
                    1. IfAbruptCloseIterator(_backupCompletion_, _iterated_).
                    1. Return ? IteratorClose(_completion_, _iterated_).
                  1. Else if _completion_ is a throw completion, then
                    1. Assert: Awaiting _innerValue_ during the Yield on step <emu-xref href="#step-async-iterator-flatmap-yield"></emu-xref> threw.
                    1. Return ? IteratorClose(_completion_, _iterated_).
          1. Return CreateAsyncIteratorFromClosure(_closure_, *"Async Iterator Helper"*, %AsyncIteratorHelperPrototype%).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asynciteratorprototype.reduce">
        <h1>AsyncIterator.prototype.reduce ( _reducer_ [ , _initialValue_ ] )</h1>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. If IsCallable(_reducer_) is *false*, throw a *TypeError* exception.
          1. If _initialValue_ is not present, then
            1. Let _next_ be ? Await(? IteratorNext(_iterated_)).
            1. If ? IteratorComplete(_next_) is *true*, throw a *TypeError* exception.
            1. Let _accumulator_ be ? IteratorValue(_next_).
          1. Else,
            1. Let _accumulator_ be _initialValue_.
          1. Repeat,
            1. Let _next_ be ? Await(? IteratorNext(_iterated_)).
            1. If ? IteratorComplete(_next_) is *true*, return _accumulator_.
            1. Let _value_ be ? IteratorValue(_next_).
            1. Let _result_ be Completion(Call(_reducer_, *undefined*, &laquo; _accumulator_, _value_ &raquo;)).
            1. IfAbruptCloseAsyncIterator(_result_, _iterated_).
            1. Set _result_ to Await(_result_).
            1. IfAbruptCloseAsyncIterator(_result_, _iterated_).
            1. Set _accumulator_ to _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asynciteratorprototype.toarray">
        <h1>AsyncIterator.prototype.toArray ( )</h1>
        <p>AsyncIterator.prototype.toArray is a built-in async function which, when called, performs the following steps:</p>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. Let _items_ be a new empty List.
          1. Repeat,
            1. Let _next_ be ? Await(? IteratorNext(_iterated_)).
            1. If ? IteratorComplete(_next_) is *true*, return CreateArrayFromList(_items_).
            1. Let _value_ be ? IteratorValue(_next_).
            1. Append _value_ to _items_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asynciteratorprototype.foreach">
        <h1>AsyncIterator.prototype.forEach ( _fn_ )</h1>
        <p>AsyncIterator.prototype.forEach is a built-in async function which, when called, performs the following steps:</p>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. If IsCallable(_fn_) is *false*, throw a *TypeError* exception.
          1. Repeat,
            1. Let _next_ be ? Await(? IteratorNext(_iterated_)).
            1. If ? IteratorComplete(_next_) is *true*, return *undefined*.
            1. Let _value_ be ? IteratorValue(_next_).
            1. Let _r_ be Completion(Call(_fn_, *undefined*, &laquo; _value_ &raquo;)).
            1. IfAbruptCloseAsyncIterator(_r_, _iterated_).
            1. Set _r_ to Await(r).
            1. IfAbruptCloseAsyncIterator(_r_, _iterated_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asynciteratorprototype.some">
        <h1>AsyncIterator.prototype.some ( _fn_ )</h1>
        <p>AsyncIterator.prototype.some is a built-in async function which, when called, performs the following steps:</p>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. If IsCallable(_fn_) is *false*, throw a *TypeError* exception.
          1. Repeat,
            1. Let _next_ be ? Await(? IteratorNext(_iterated_)).
            1. If ? IteratorComplete(_next_) is *true*, return *false*.
            1. Let _value_ be ? IteratorValue(_next_).
            1. Let _result_ be Completion(Call(_fn_, *undefined*, &laquo; _value_ &raquo;)).
            1. IfAbruptCloseAsyncIterator(_result_, _iterated_).
            1. Set _result_ to Await(_result_).
            1. IfAbruptCloseAsyncIterator(_result_, _iterated_).
            1. If ToBoolean(_result_) is *true*, return ? AsyncIteratorClose(_iterated_, NormalCompletion(*true*)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asynciteratorprototype.every">
        <h1>AsyncIterator.prototype.every ( _fn_ )</h1>
        <p>AsyncIterator.prototype.every is a built-in async function which, when called, performs the following steps:</p>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. If IsCallable(_fn_) is *false*, throw a *TypeError* exception.
          1. Repeat,
            1. Let _next_ be ? Await(? IteratorNext(_iterated_)).
            1. If ? IteratorComplete(_next_) is *true*, return *true*.
            1. Let _value_ be ? IteratorValue(_next_).
            1. Let _result_ be Completion(Call(_fn_, *undefined*, &laquo; _value_ &raquo;)).
            1. IfAbruptCloseAsyncIterator(_result_, _iterated_).
            1. Set _result_ to Await(_result_).
            1. IfAbruptCloseAsyncIterator(_result_, _iterated_).
            1. If ToBoolean(_result_) is *false*, return ? AsyncIteratorClose(_iterated_, NormalCompletion(*false*)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asynciteratorprototype.find">
        <h1>AsyncIterator.prototype.find ( _fn_ )</h1>
        <p>AsyncIterator.prototype.find is a built-in async function which, when called, performs the following steps:</p>
        <emu-alg>
          1. Let _iterated_ be ? GetIteratorDirect(*this* value).
          1. If IsCallable(_fn_) is *false*, throw a *TypeError* exception.
          1. Repeat,
            1. Let _next_ be ? Await(? IteratorNext(_iterated_)).
            1. If ? IteratorComplete(_next_) is *true*, return *undefined*.
            1. Let _value_ be ? IteratorValue(_next_).
            1. Let _result_ be Completion(Call(_fn_, *undefined*, &laquo; _value_ &raquo;)).
            1. IfAbruptCloseAsyncIterator(_result_, _iterated_).
            1. Set _result_ to Await(_result_).
            1. IfAbruptCloseAsyncIterator(_result_, _iterated_).
            1. If ToBoolean(_result_) is *true*, return ? AsyncIteratorClose(_iterated_, NormalCompletion(_value_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asynciteratorprototype-@@tostringtag">
        <h1>AsyncIterator.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value "Async Iterator".</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-new-asyncgenerator-aos">
  <h1>New AsyncGenerator AOs</h1>
  <p>These factor out functionality from AsyncGenerator.prototype.next and AsyncGenerator.prototype.return and should be used in those methods when this proposal lands in the main specification.</p>

  <emu-clause id="sec-asyncgenerator-next" type="abstract operation">
    <h1>
      AsyncGeneratorNext (
        _generator_: unknown,
        _brand_: unknown,
        _value_: an ECMAScript language value,
      ): an ECMAScript language value
    </h1>
    <dl class="header">
    </dl>
    <emu-alg>
      1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
      1. Let _result_ be Completion(AsyncGeneratorValidate(_generator_, _brand_)).
      1. IfAbruptRejectPromise(_result_, _promiseCapability_).
      1. Let _state_ be _generator_.[[AsyncGeneratorState]].
      1. If _state_ is ~completed~, then
        1. Let _iteratorResult_ be CreateIterResultObject(*undefined*, *true*).
        1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _iteratorResult_ &raquo;).
        1. Return _promiseCapability_.[[Promise]].
      1. Let _completion_ be NormalCompletion(_value_).
      1. Perform AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_).
      1. If _state_ is either ~suspendedStart~ or ~suspendedYield~, then
        1. Perform AsyncGeneratorResume(_generator_, _completion_).
      1. Else,
        1. Assert: _state_ is either ~executing~ or ~awaiting-return~.
      1. Return _promiseCapability_.[[Promise]].
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-asyncgenerator-return" type="abstract operation">
    <h1>
      AsyncGeneratorReturn (
        _generator_: unknown,
        _brand_: unknown,
        _value_: an ECMAScript language value,
      ): an ECMAScript language value
    </h1>
    <dl class="header">
    </dl>
    <emu-alg>
      1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
      1. Let _result_ be Completion(AsyncGeneratorValidate(_generator_, _brand_)).
      1. IfAbruptRejectPromise(_result_, _promiseCapability_).
      1. Let _completion_ be Completion Record { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }.
      1. Perform AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_).
      1. Let _state_ be _generator_.[[AsyncGeneratorState]].
      1. If _state_ is either ~suspendedStart~ or ~completed~, then
        1. Set _generator_.[[AsyncGeneratorState]] to ~awaiting-return~.
        1. Perform ! AsyncGeneratorAwaitReturn(_generator_).
      1. Else if _state_ is ~suspendedYield~, then
        1. Perform AsyncGeneratorResume(_generator_, _completion_).
      1. Else,
        1. Assert: _state_ is either ~executing~ or ~awaiting-return~.
      1. Return _promiseCapability_.[[Promise]].
    </emu-alg>
  </emu-clause>
</emu-clause>
